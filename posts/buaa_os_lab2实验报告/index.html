<!doctype html><html lang=en dir=auto><head><meta charset=utf-8><meta http-equiv=x-ua-compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>BUAA_OS_Lab2实验报告 | Qcloud's Blog</title><meta name=keywords content><meta name=description content="Lab2 实验报告 01 实验思考题 Thinking 2.1 请你根据上述说明，回答问题：
  在我们编写的程序中，指针变量中存储的地址是虚拟地址还是物理地址？
答：虚拟地址。
  MIPS 汇编程序中lw, sw使用的是虚拟地址还是物理地址？
答：虚拟地址。
   Thinking 2.2   请从可重用性的角度，阐述用宏来实现链表的好处。
答：由于C语言并不支持泛型，所以我们通过宏来实现链表，使其具有”泛型“的特点。这样所有的链表都可以使用一套宏，实现了代码的复用，提高了可重用性。
  请你查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。
答：在 queue.h 中可以看到：
/* 双向链表 * A list is headed by a single forward pointer(or an array of forward * pointers for a hash table header). The elements are doubly linked * so that an arbitrary element can be removed without a need to * traverse the list."><meta name=author content><link rel=canonical href=http://qcloudq.github.io/myblog/posts/buaa_os_lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/><link crossorigin=anonymous href=/myblog/assets/css/stylesheet.min.ec8da366ca2fb647537ccb7a8f6fa5b4e9cd3c7a0d3171dd2d3baad1e49c8bfc.css integrity="sha256-7I2jZsovtkdTfMt6j2+ltOnNPHoNMXHdLTuq0eSci/w=" rel="preload stylesheet" as=style><script defer crossorigin=anonymous src=/myblog/assets/js/highlight.min.2840b7fccd34145847db71a290569594bdbdb00047097f75d6495d162f5d7dff.js integrity="sha256-KEC3/M00FFhH23GikFaVlL29sABHCX911kldFi9dff8=" onload=hljs.initHighlightingOnLoad()></script>
<link rel=icon href=http://qcloudq.github.io/myblog/favicon.ico><link rel=icon type=image/png sizes=16x16 href=http://qcloudq.github.io/myblog/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=http://qcloudq.github.io/myblog/favicon-32x32.png><link rel=apple-touch-icon href=http://qcloudq.github.io/myblog/apple-touch-icon.png><link rel=mask-icon href=http://qcloudq.github.io/myblog/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--hljs-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51)}.list{background:var(--theme)}.list:not(.dark)::-webkit-scrollbar-track{background:0 0}.list:not(.dark)::-webkit-scrollbar-thumb{border-color:var(--theme)}}</style></noscript><meta property="og:title" content="BUAA_OS_Lab2实验报告"><meta property="og:description" content="Lab2 实验报告 01 实验思考题 Thinking 2.1 请你根据上述说明，回答问题：
  在我们编写的程序中，指针变量中存储的地址是虚拟地址还是物理地址？
答：虚拟地址。
  MIPS 汇编程序中lw, sw使用的是虚拟地址还是物理地址？
答：虚拟地址。
   Thinking 2.2   请从可重用性的角度，阐述用宏来实现链表的好处。
答：由于C语言并不支持泛型，所以我们通过宏来实现链表，使其具有”泛型“的特点。这样所有的链表都可以使用一套宏，实现了代码的复用，提高了可重用性。
  请你查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。
答：在 queue.h 中可以看到：
/* 双向链表 * A list is headed by a single forward pointer(or an array of forward * pointers for a hash table header). The elements are doubly linked * so that an arbitrary element can be removed without a need to * traverse the list."><meta property="og:type" content="article"><meta property="og:url" content="http://qcloudq.github.io/myblog/posts/buaa_os_lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"><meta property="article:section" content="posts"><meta property="article:published_time" content="2022-05-05T07:08:23+08:00"><meta property="article:modified_time" content="2022-05-05T07:08:23+08:00"><meta name=twitter:card content="summary"><meta name=twitter:title content="BUAA_OS_Lab2实验报告"><meta name=twitter:description content="Lab2 实验报告 01 实验思考题 Thinking 2.1 请你根据上述说明，回答问题：
  在我们编写的程序中，指针变量中存储的地址是虚拟地址还是物理地址？
答：虚拟地址。
  MIPS 汇编程序中lw, sw使用的是虚拟地址还是物理地址？
答：虚拟地址。
   Thinking 2.2   请从可重用性的角度，阐述用宏来实现链表的好处。
答：由于C语言并不支持泛型，所以我们通过宏来实现链表，使其具有”泛型“的特点。这样所有的链表都可以使用一套宏，实现了代码的复用，提高了可重用性。
  请你查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。
答：在 queue.h 中可以看到：
/* 双向链表 * A list is headed by a single forward pointer(or an array of forward * pointers for a hash table header). The elements are doubly linked * so that an arbitrary element can be removed without a need to * traverse the list."><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":2,"name":"Posts","item":"http://qcloudq.github.io/myblog/posts/"},{"@type":"ListItem","position":3,"name":"BUAA_OS_Lab2实验报告","item":"http://qcloudq.github.io/myblog/posts/buaa_os_lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"BUAA_OS_Lab2实验报告","name":"BUAA_OS_Lab2实验报告","description":"Lab2 实验报告 01 实验思考题 Thinking 2.1 请你根据上述说明，回答问题：\n  在我们编写的程序中，指针变量中存储的地址是虚拟地址还是物理地址？\n答：虚拟地址。\n  MIPS 汇编程序中lw, sw使用的是虚拟地址还是物理地址？\n答：虚拟地址。\n   Thinking 2.2   请从可重用性的角度，阐述用宏来实现链表的好处。\n答：由于C语言并不支持泛型，所以我们通过宏来实现链表，使其具有”泛型“的特点。这样所有的链表都可以使用一套宏，实现了代码的复用，提高了可重用性。\n  请你查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。\n答：在 queue.h 中可以看到：\n/* 双向链表 * A list is headed by a single forward pointer(or an array of forward * pointers for a hash table header). The elements are doubly linked * so that an arbitrary element can be removed without a need to * traverse the list.","keywords":[],"articleBody":"Lab2 实验报告 01 实验思考题 Thinking 2.1 请你根据上述说明，回答问题：\n  在我们编写的程序中，指针变量中存储的地址是虚拟地址还是物理地址？\n答：虚拟地址。\n  MIPS 汇编程序中lw, sw使用的是虚拟地址还是物理地址？\n答：虚拟地址。\n   Thinking 2.2   请从可重用性的角度，阐述用宏来实现链表的好处。\n答：由于C语言并不支持泛型，所以我们通过宏来实现链表，使其具有”泛型“的特点。这样所有的链表都可以使用一套宏，实现了代码的复用，提高了可重用性。\n  请你查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。\n答：在 queue.h 中可以看到：\n/* 双向链表 * A list is headed by a single forward pointer(or an array of forward * pointers for a hash table header). The elements are doubly linked * so that an arbitrary element can be removed without a need to * traverse the list. New elements can be added to the list before * or after an existing element or at the head of the list. A list * may only be traversed in the forward direction. */ /* 单向链表 * A singly-linked list is headed by a single forward pointer. The * elements are singly linked for minimum space and pointer manipulation * overhead at the expense of O(n) removal for arbitrary elements. New * elements can be added to the list after an existing element or at the * head of the list. Elements being removed from the head of the list * should use the explicit macro for this purpose for optimum * efficiency. A singly-linked list may only be traversed in the forward * direction. Singly-linked lists are ideal for applications with large * datasets and few or no removals or for implementing a LIFO queue. */ /* 循环链表 * A circle queue is headed by a pair of pointers, one to the head of the * list and the other to the tail of the list. The elements are doubly * linked so that an arbitrary element can be removed without a need to * traverse the list. New elements can be added to the list before or after * an existing element, at the head of the list, or at the end of the list. * A circle queue may be traversed in either direction, but has a more * complex end of list detection. */ 双向链表 List：\n 插入：List 的插入操作提供了 LIST_INSERT_AFTER、LIST_INSERT_BEFORE 和 LIST_INSERT_HEAD ，都不需要遍历，时间复杂度均为 O(1)。但由于其只有一个指向头部的指针，所以如果想要在尾部插入一个元素，需要遍历链表，时间复杂度为O(n)。 删除：List 的删除操作为 LIST_REMOVE ，时间复杂度为 O(1)。  单向链表 Singly-linked List：\n 插入：Singly-linked List 的插入操作只提供了 SLIST_INSERT_AFTER、SLIST_INSERT_HEAD ，时间复杂度均为O(1)。由于单向链表的元素只有一个指向后一个元素的指针，所以如果想要在前面插入一个元素，需要遍历链表，时间复杂度为O(n)。 删除：Singly-linked List 的删除操作有 SLIST_REMOVE_HEAD 、SLIST_REMOVE 。 SLIST_REMOVE_HEAD 的时间复杂度为 O(1)，因为单向链表有一个指向头部的指针。而 SLIST_REMOVE 的时间复杂度为 O(n)。由于单向链表结构占用空间比双向链表小，所以单向链表适合数据量非常大而几乎不需要删除数据的场合。  循环链表 Circular queue：\n 插入：Circular queue 的插入操作提供了 CIRCLEQ_INSERT_AFTER、CIRCLEQ_INSERT_BEFORE、CIRCLEQ_INSERT_HEAD、CIRCLEQ_INSERT_TAIL 。循环链表具有一个指向尾部的指针，所以可以直接在尾部插入元素。同时，由于其多储存了一个指向尾部的指针，所以占用空间比双向链表多。循环链表的插入操作时间复杂度均为 O(1)。 删除：Circular queue 的删除操作为 CIRCLEQ_REMOVE ，时间复杂度为 O(1)。     Thinking 2.3 请阅读 include/queue.h 以及 include/pmap.h, 将 Page_list 的结构梳理清楚，选择正确的展开结构。\n答：正确的展开结构为 C 。\nC: struct Page_list{  struct {  struct {  struct Page *le_next;  struct Page **le_prev;  } pp_link;  u_short pp_ref;  }* lh_first; }  Thinking 2.4 请你寻找上述两个 boot_* 函数在何处被调用。\n答：boot_pgdir_walk 在 boot_map_segment 中被调用，用于在建立虚拟地址区间到物理地址区间的映射时，根据虚拟地址返回对应的二级页表项。\n​\tboot_map_segment 在 mips_vm_init 中被调用，用于将 UPAGES 和 UENVS 映射到对应的物理地址区间。\n Thinking 2.5 请你思考下述两个问题：\n  请阅读上面有关 R3000-TLB 的叙述，从虚拟内存的实现角度，阐述 ASID 的必要性\nLinux 内核给每个进程都提供了一个独立的虚拟地址空间，而同一虚拟地址在不同的地址空间中通常映射到不同的物理地址，所以需要 ASID 来帮助区分不同的地址空间，以免映射到错误的物理地址。\n  请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID 段的位数，说明 R3000 中可容纳不同的地址空间的最大数量\nEntryHi 的位结构如上图，可以看到 ASID 段有 6 位。\n By setting up TLB entries with a particular ASID setting and with the EntryLo G bit zero, those entries will only ever match a program address when the CPU’s ASID register is set the same. This allows software to map up to 64 different address spaces simultaneously, without requiring that the OS clear out the TLB on a context change.\n—-《IDT R30xx Family Software Reference Manual》\n 所以 R3000 中可容纳不同地址空间的最大数量为 64 个。\n   Thinking 2.6 请你完成如下三个任务：\n  tlb_invalidate 和 tlb_out 的调用关系是怎样的？\ntlb_invalidate 调用了 tlb_out 。\n  请用一句话概括 tlb_invalidate 的作用\n更新 TLB 。\n  逐行解释 tlb_out 中的汇编代码\nLEAF(tlb_out) //1: j 1b nop  mfc0 k1,CP0_ENTRYHI //将EntryHi寄存器的值存入k1寄存器中  mtc0 a0,CP0_ENTRYHI //将a0寄存器的值存入EntryHi寄存器中  nop  tlbp //根据EntryHi中的值，查找TLB中与之对应的表项  //并将表项的索引存入Index寄存器  //若未找到匹配项，则Index最高位被置1  nop  nop  nop  nop  mfc0 k0,CP0_INDEX //将Index寄存器的值存入k0寄存器中  bltz k0,NOFOUND\t//如果k0的值小于0，即没有找到匹配项  //跳转到NOFOUND  nop  mtc0 zero,CP0_ENTRYHI //将EntryHi寄存器置0  mtc0 zero,CP0_ENTRYLO0 //将EntryLo寄存器置0  nop  tlbwi //以Index寄存器中的值为索引,将EntryHi和EntryLo的值写到对应TLB表项中 NOFOUND:   mtc0 k1,CP0_ENTRYHI //将k1寄存器的值存入EntryHi寄存器中 \t//即恢复EntryHi初始状态  j ra //返回  nop END(tlb_out)    Thinking 2.7 在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为 8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64 位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若记三级页表的基地址为 PTbase ，请你计算：\n  三级页表页目录的基地址 $$ PD_{base}=PT_{base}|PT_{base}\\gg 9|PT_{base}\\gg 18 $$\n  映射到页目录自身的页目录项(自映射)\n  $$ PDE_{self-mapping}=PT_{base}|PT_{base}\\gg 9|PT_{base}\\gg 18|PT_{base}\\gg 27 $$\n Thinking 2.8   简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。\n  X86 架构中对内存的管理使用两种方式，即分段和分页。\n在 X86 架构中内存被分为三种形式，分别是逻辑地址，线性地址和物理地址。如下图所示，通过分段可以将逻辑地址转换为线性地址，而通过分页可以将线性地址转换为物理地址。\n  MIPS 架构对内存使用分页管理。\n  X86 架构采用硬件TLB重填，即由硬件完成页表遍历，将所需的页表项填入TLB中。\n  MIPS 架构采用软件TLB重填，即查找TLB发现不命中时，将触发TLB重填异常，由异常处理程序进行页表遍历并进行TLB填入。\n    02 实验难点 链表宏 本次实验中，对链表宏的理解是一大难题。可以借助助教发的图帮助理解。\n页目录自映射 页目录自映射也是一大难题。可以借助实验指导书上的图加以理解。\n03 体会与感想 ​\t本次实验我花费了挺长时间来理解概念，恶补理论课知识。在做 Lab 2-2 前，我先把理论课作业做了，里面有一道虚拟地址访存题，帮助我很好地理解了两级页表的结构，补充了相关知识来完成第二部分的实验。\n​\t最痛苦的是理解页目录自映射，我可能脑子缺了一根筋，怎么都想象不出来是怎么映射的。看理论课ppt也看不懂，网上搜大佬的博客来看也看不懂。直到有一天早上爬起来继续在电脑上看指导书，突然被上面那张指导书上的图击中了，茅塞顿开，醍醐灌顶，福至心灵，理解了它是怎么实现的，所以可能真的要多睡觉（不是）。\n","wordCount":"667","inLanguage":"en","datePublished":"2022-05-05T07:08:23+08:00","dateModified":"2022-05-05T07:08:23+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"http://qcloudq.github.io/myblog/posts/buaa_os_lab2%E5%AE%9E%E9%AA%8C%E6%8A%A5%E5%91%8A/"},"publisher":{"@type":"Organization","name":"Qcloud's Blog","logo":{"@type":"ImageObject","url":"http://qcloudq.github.io/myblog/favicon.ico"}}}</script></head><body id=top><script>localStorage.getItem("pref-theme")==="dark"?document.body.classList.add("dark"):localStorage.getItem("pref-theme")==="light"?document.body.classList.remove("dark"):window.matchMedia("(prefers-color-scheme: dark)").matches&&document.body.classList.add("dark")</script><header class=header><nav class=nav><div class=logo><a href=http://qcloudq.github.io/myblog accesskey=h title="Qcloud's Blog (Alt + H)">Qcloud's Blog</a>
<span class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)"><svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg><svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentcolor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button></span></div><ul id=menu><li><a href=http://qcloudq.github.io/myblog/archives title=Archive><span>Archive</span></a></li><li><a href=http://qcloudq.github.io/myblog title=Home><span>Home</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class=post-title>BUAA_OS_Lab2实验报告</h1><div class=post-meta><span title="2022-05-05 07:08:23 +0800 +0800">May 5, 2022</span></div></header><div class=post-content><h1 id=lab2-实验报告>Lab2 实验报告<a hidden class=anchor aria-hidden=true href=#lab2-实验报告>#</a></h1><h2 id=01-实验思考题>01 实验思考题<a hidden class=anchor aria-hidden=true href=#01-实验思考题>#</a></h2><h3 id=thinking-21>Thinking 2.1<a hidden class=anchor aria-hidden=true href=#thinking-21>#</a></h3><p><strong>请你根据上述说明，回答问题：</strong></p><ul><li><p><strong>在我们编写的程序中，指针变量中存储的地址是虚拟地址还是物理地址？</strong></p><p>答：虚拟地址。</p></li><li><p><strong>MIPS 汇编程序中lw, sw使用的是虚拟地址还是物理地址？</strong></p><p>答：虚拟地址。</p></li></ul><hr><h3 id=thinking-22>Thinking 2.2<a hidden class=anchor aria-hidden=true href=#thinking-22>#</a></h3><ul><li><p><strong>请从可重用性的角度，阐述用宏来实现链表的好处。</strong></p><p>答：由于C语言并不支持泛型，所以我们通过宏来实现链表，使其具有”泛型“的特点。这样所有的链表都可以使用一套宏，实现了代码的复用，提高了可重用性。</p></li><li><p><strong>请你查看实验环境中的 /usr/include/sys/queue.h，了解其中单向链表与循环链表的实现，比较它们与本实验中使用的双向链表，分析三者在插入与删除操作上的性能差异。</strong></p><p>答：在 queue.h 中可以看到：</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* 双向链表
</span></span></span><span style=display:flex><span><span style=color:#75715e> * A list is headed by a single forward pointer(or an array of forward
</span></span></span><span style=display:flex><span><span style=color:#75715e> * pointers for a hash table header). The elements are doubly linked
</span></span></span><span style=display:flex><span><span style=color:#75715e> * so that an arbitrary element can be removed without a need to
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traverse the list. New elements can be added to the list before
</span></span></span><span style=display:flex><span><span style=color:#75715e> * or after an existing element or at the head of the list. A list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * may only be traversed in the forward direction.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span> 
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* 单向链表
</span></span></span><span style=display:flex><span><span style=color:#75715e> * A singly-linked list is headed by a single forward pointer. The
</span></span></span><span style=display:flex><span><span style=color:#75715e> * elements are singly linked for minimum space and pointer manipulation
</span></span></span><span style=display:flex><span><span style=color:#75715e> * overhead at the expense of O(n) removal for arbitrary elements. New
</span></span></span><span style=display:flex><span><span style=color:#75715e> * elements can be added to the list after an existing element or at the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * head of the list.  Elements being removed from the head of the list
</span></span></span><span style=display:flex><span><span style=color:#75715e> * should use the explicit macro for this purpose for optimum
</span></span></span><span style=display:flex><span><span style=color:#75715e> * efficiency. A singly-linked list may only be traversed in the forward
</span></span></span><span style=display:flex><span><span style=color:#75715e> * direction.  Singly-linked lists are ideal for applications with large
</span></span></span><span style=display:flex><span><span style=color:#75715e> * datasets and few or no removals or for implementing a LIFO queue.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span> 
</span></span></code></pre></div><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span><span style=color:#75715e>/* 循环链表
</span></span></span><span style=display:flex><span><span style=color:#75715e> * A circle queue is headed by a pair of pointers, one to the head of the
</span></span></span><span style=display:flex><span><span style=color:#75715e> * list and the other to the tail of the list. The elements are doubly
</span></span></span><span style=display:flex><span><span style=color:#75715e> * linked so that an arbitrary element can be removed without a need to
</span></span></span><span style=display:flex><span><span style=color:#75715e> * traverse the list. New elements can be added to the list before or after
</span></span></span><span style=display:flex><span><span style=color:#75715e> * an existing element, at the head of the list, or at the end of the list.
</span></span></span><span style=display:flex><span><span style=color:#75715e> * A circle queue may be traversed in either direction, but has a more
</span></span></span><span style=display:flex><span><span style=color:#75715e> * complex end of list detection.
</span></span></span><span style=display:flex><span><span style=color:#75715e>*/</span> 
</span></span></code></pre></div><p><strong>双向链表 List：</strong></p><ul><li>插入：List 的插入操作提供了 <code>LIST_INSERT_AFTER</code>、<code>LIST_INSERT_BEFORE</code> 和 <code>LIST_INSERT_HEAD</code> ，都不需要遍历，时间复杂度均为 O(1)。但由于其只有一个指向头部的指针，所以如果想要在尾部插入一个元素，需要遍历链表，时间复杂度为O(n)。</li><li>删除：List 的删除操作为 <code>LIST_REMOVE</code> ，时间复杂度为 O(1)。</li></ul><p><strong>单向链表 Singly-linked List：</strong></p><ul><li>插入：Singly-linked List 的插入操作只提供了 <code>SLIST_INSERT_AFTER</code>、<code>SLIST_INSERT_HEAD</code> ，时间复杂度均为O(1)。由于单向链表的元素只有一个指向后一个元素的指针，所以如果想要在前面插入一个元素，需要遍历链表，时间复杂度为O(n)。</li><li>删除：Singly-linked List 的删除操作有 <code>SLIST_REMOVE_HEAD</code> 、<code>SLIST_REMOVE</code> 。 <code>SLIST_REMOVE_HEAD</code> 的时间复杂度为 O(1)，因为单向链表有一个指向头部的指针。而 <code>SLIST_REMOVE</code> 的时间复杂度为 O(n)。由于单向链表结构占用空间比双向链表小，所以单向链表适合数据量非常大而几乎不需要删除数据的场合。</li></ul><p><strong>循环链表 Circular queue：</strong></p><ul><li>插入：Circular queue 的插入操作提供了 <code>CIRCLEQ_INSERT_AFTER</code>、<code>CIRCLEQ_INSERT_BEFORE</code>、<code>CIRCLEQ_INSERT_HEAD</code>、<code>CIRCLEQ_INSERT_TAIL</code> 。循环链表具有一个指向尾部的指针，所以可以直接在尾部插入元素。同时，由于其多储存了一个指向尾部的指针，所以占用空间比双向链表多。循环链表的插入操作时间复杂度均为 O(1)。</li><li>删除：Circular queue 的删除操作为 <code>CIRCLEQ_REMOVE</code> ，时间复杂度为 O(1)。</li></ul></li></ul><hr><h3 id=thinking-23>Thinking 2.3<a hidden class=anchor aria-hidden=true href=#thinking-23>#</a></h3><p><strong>请阅读 <code>include/queue.h</code> 以及 <code>include/pmap.h</code>, 将 <code>Page_list</code> 的结构梳理清楚，选择正确的展开结构。</strong></p><p>答：正确的展开结构为 <strong>C</strong> 。</p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>C:
</span></span><span style=display:flex><span><span style=color:#66d9ef>struct</span> Page_list{
</span></span><span style=display:flex><span>    <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>        <span style=color:#66d9ef>struct</span> {
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> Page <span style=color:#f92672>*</span>le_next;
</span></span><span style=display:flex><span>            <span style=color:#66d9ef>struct</span> Page <span style=color:#f92672>**</span>le_prev;
</span></span><span style=display:flex><span>        } pp_link;
</span></span><span style=display:flex><span>        u_short pp_ref;
</span></span><span style=display:flex><span>    }<span style=color:#f92672>*</span> lh_first;
</span></span><span style=display:flex><span>}
</span></span></code></pre></div><hr><h3 id=thinking-24>Thinking 2.4<a hidden class=anchor aria-hidden=true href=#thinking-24>#</a></h3><p><strong>请你寻找上述两个 boot_* 函数在何处被调用。</strong></p><p>答：<code>boot_pgdir_walk</code> 在 <code>boot_map_segment</code> 中被调用，用于在建立虚拟地址区间到物理地址区间的映射时，根据虚拟地址返回对应的二级页表项。</p><p>​ <code>boot_map_segment</code> 在 <code>mips_vm_init</code> 中被调用，用于将 <code>UPAGES</code> 和 <code>UENVS</code> 映射到对应的物理地址区间。</p><hr><h3 id=thinking-25>Thinking 2.5<a hidden class=anchor aria-hidden=true href=#thinking-25>#</a></h3><p><strong>请你思考下述两个问题：</strong></p><ul><li><p><strong>请阅读上面有关 R3000-TLB 的叙述，从虚拟内存的实现角度，阐述 ASID 的必要性</strong></p><p>Linux 内核给每个进程都提供了一个独立的虚拟地址空间，而同一虚拟地址在不同的地址空间中通常映射到不同的物理地址，所以需要 ASID 来帮助区分不同的地址空间，以免映射到错误的物理地址。</p></li><li><p><strong>请阅读《IDT R30xx Family Software Reference Manual》的 Chapter 6，结合 ASID 段的位数，说明 R3000 中可容纳不同的地址空间的最大数量</strong></p><p><img loading=lazy src=https://s3.bmp.ovh/imgs/2022/05/05/359c8c9c8af2dba0.png alt></p><p><code>EntryHi</code> 的位结构如上图，可以看到 ASID 段有 <strong>6</strong> 位。</p><blockquote><p>By setting up TLB entries with a particular ASID setting and with the EntryLo G bit zero, those entries will only ever match a program address when the CPU’s ASID register is set the same. This allows software to map up to <strong>64 different address spaces</strong> simultaneously, without requiring that the OS clear out the TLB on a context change.</p><p>&mdash;-《IDT R30xx Family Software Reference Manual》</p></blockquote><p>所以 R3000 中可容纳不同地址空间的最大数量为 <strong>64</strong> 个。</p></li></ul><hr><h3 id=thinking-26>Thinking 2.6<a hidden class=anchor aria-hidden=true href=#thinking-26>#</a></h3><p><strong>请你完成如下三个任务：</strong></p><ul><li><p><strong>tlb_invalidate 和 tlb_out 的调用关系是怎样的？</strong></p><p><code>tlb_invalidate</code> 调用了 <code>tlb_out</code> 。</p></li><li><p><strong>请用一句话概括 tlb_invalidate 的作用</strong></p><p>更新 TLB 。</p></li><li><p><strong>逐行解释 tlb_out 中的汇编代码</strong></p><div class=highlight><pre tabindex=0 style=color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4><code class=language-c data-lang=c><span style=display:flex><span>LEAF(tlb_out)
</span></span><span style=display:flex><span><span style=color:#75715e>//1: j 1b
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>nop
</span></span><span style=display:flex><span>    mfc0    k1,CP0_ENTRYHI   <span style=color:#75715e>//将EntryHi寄存器的值存入k1寄存器中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mtc0    a0,CP0_ENTRYHI   <span style=color:#75715e>//将a0寄存器的值存入EntryHi寄存器中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    nop
</span></span><span style=display:flex><span>    tlbp    <span style=color:#75715e>//根据EntryHi中的值，查找TLB中与之对应的表项
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    		<span style=color:#75715e>//并将表项的索引存入Index寄存器
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    		<span style=color:#75715e>//若未找到匹配项，则Index最高位被置1
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    nop
</span></span><span style=display:flex><span>    nop
</span></span><span style=display:flex><span>    nop
</span></span><span style=display:flex><span>    nop
</span></span><span style=display:flex><span>    mfc0    k0,CP0_INDEX     <span style=color:#75715e>//将Index寄存器的值存入k0寄存器中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    bltz    k0,NOFOUND		 <span style=color:#75715e>//如果k0的值小于0，即没有找到匹配项
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    						 <span style=color:#75715e>//跳转到NOFOUND
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    nop
</span></span><span style=display:flex><span>    mtc0    zero,CP0_ENTRYHI  <span style=color:#75715e>//将EntryHi寄存器置0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    mtc0    zero,CP0_ENTRYLO0 <span style=color:#75715e>//将EntryLo寄存器置0
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    nop
</span></span><span style=display:flex><span>    tlbwi   <span style=color:#75715e>//以Index寄存器中的值为索引,将EntryHi和EntryLo的值写到对应TLB表项中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>NOFOUND:
</span></span><span style=display:flex><span>
</span></span><span style=display:flex><span>    mtc0    k1,CP0_ENTRYHI  <span style=color:#75715e>//将k1寄存器的值存入EntryHi寄存器中
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>							<span style=color:#75715e>//即恢复EntryHi初始状态
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    j   ra  <span style=color:#75715e>//返回
</span></span></span><span style=display:flex><span><span style=color:#75715e></span>    nop
</span></span><span style=display:flex><span>END(tlb_out)
</span></span></code></pre></div></li></ul><hr><h3 id=thinking-27>Thinking 2.7<a hidden class=anchor aria-hidden=true href=#thinking-27>#</a></h3><p><strong>在现代的 64 位系统中，提供了 64 位的字长，但实际上不是 64 位页式存储系统。假设在 64 位系统中采用三级页表机制，页面大小 4KB。由于 64 位系统中字长为 8B，且页目录也占用一页，因此页目录中有 512 个页目录项，因此每级页表都需要 9 位。因此在 64 位系统下，总共需要 3 × 9 + 12 = 39 位就可以实现三级页表机制，并不需要 64 位。现考虑上述 39 位的三级页式存储系统，虚拟地址空间为 512 GB，若记三级页表的基地址为 PTbase ，请你计算：</strong></p><ul><li><p><strong>三级页表页目录的基地址</strong>
$$
PD_{base}=PT_{base}|PT_{base}\gg 9|PT_{base}\gg 18
$$</p></li><li><p><strong>映射到页目录自身的页目录项(自映射)</strong></p></li></ul><p>$$
PDE_{self-mapping}=PT_{base}|PT_{base}\gg 9|PT_{base}\gg 18|PT_{base}\gg 27
$$</p><hr><h3 id=thinking-28>Thinking 2.8<a hidden class=anchor aria-hidden=true href=#thinking-28>#</a></h3><ul><li><p><strong>简单了解并叙述 X86 体系结构中的内存管理机制，比较 X86 和 MIPS 在内存管理上的区别。</strong></p><ul><li><p>X86 架构中对内存的管理使用两种方式，即分段和分页。</p><p>在 X86 架构中内存被分为三种形式，分别是逻辑地址，线性地址和物理地址。如下图所示，通过分段可以将逻辑地址转换为线性地址，而通过分页可以将线性地址转换为物理地址。</p><p><img loading=lazy src=https://s3.bmp.ovh/imgs/2022/05/05/bb45af700757f0ae.png alt></p></li><li><p>MIPS 架构对内存使用分页管理。</p></li><li><p>X86 架构采用硬件TLB重填，即由硬件完成页表遍历，将所需的页表项填入TLB中。</p></li><li><p>MIPS 架构采用软件TLB重填，即查找TLB发现不命中时，将触发TLB重填异常，由异常处理程序进行页表遍历并进行TLB填入。</p></li></ul></li></ul><h2 id=02-实验难点>02 实验难点<a hidden class=anchor aria-hidden=true href=#02-实验难点>#</a></h2><h4 id=链表宏>链表宏<a hidden class=anchor aria-hidden=true href=#链表宏>#</a></h4><p>本次实验中，对链表宏的理解是一大难题。可以借助助教发的图帮助理解。</p><p><img loading=lazy src=https://s3.bmp.ovh/imgs/2022/05/05/c266b9262b3a7b4b.jpg alt></p><h4 id=页目录自映射>页目录自映射<a hidden class=anchor aria-hidden=true href=#页目录自映射>#</a></h4><p>页目录自映射也是一大难题。可以借助实验指导书上的图加以理解。</p><p><img loading=lazy src=https://s3.bmp.ovh/imgs/2022/05/05/d5a6891878ec60af.png alt></p><h2 id=03-体会与感想>03 体会与感想<a hidden class=anchor aria-hidden=true href=#03-体会与感想>#</a></h2><p>​ 本次实验我花费了挺长时间来理解概念，恶补理论课知识。在做 Lab 2-2 前，我先把理论课作业做了，里面有一道虚拟地址访存题，帮助我很好地理解了两级页表的结构，补充了相关知识来完成第二部分的实验。</p><p>​ 最痛苦的是理解页目录自映射，我可能脑子缺了一根筋，怎么都想象不出来是怎么映射的。看理论课ppt也看不懂，网上搜大佬的博客来看也看不懂。直到有一天早上爬起来继续在电脑上看指导书，突然被上面那张指导书上的图击中了，茅塞顿开，醍醐灌顶，福至心灵，理解了它是怎么实现的，所以可能真的要多睡觉（不是）。</p></div><footer class=post-footer><ul class=post-tags></ul></footer></article></main><footer class=footer><span>&copy; 2022 <a href=http://qcloudq.github.io/myblog>Qcloud's Blog</a></span>
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
        <a href=https://git.io/hugopapermod rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentcolor"><path d="M12 6H0l6-6z"/></svg></a><script>let menu=document.getElementById("menu");menu&&(menu.scrollLeft=localStorage.getItem("menu-scroll-position"),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}),document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(t){t.preventDefault();var e=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(e)}']`).scrollIntoView({behavior:"smooth"}),e==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${e}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{document.body.className.includes("dark")?(document.body.classList.remove("dark"),localStorage.setItem("pref-theme","light")):(document.body.classList.add("dark"),localStorage.setItem("pref-theme","dark"))})</script></body></html>